{
    "Template minimal": {
        "prefix": "fj",
        "body": [
            "",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define files                        \\",
            "    freopen(\"input.txt\", \"r\", stdin); \\",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "",
            "#define rall(x) x.rbegin(), x.rend()",
            "#define all(x) x.begin(), x.end()",
            "#define sz(x) (int)x.size()",
            "#define ll long long",
            "",
            "#define rep(ii, beg, till, inc) for (int ii = beg; ii < till; ii += inc)",
            "#define repr(ii, beg, till, inc) for (int ii = beg - 1; ii >= till; ii -= inc)",
            "",
            "const ll MOD = 1e9 + 7;",
            "const int MXN = 2e5 + 5;",
            "",
            "int dx[] = {1, -1, 0, 0};",
            "int dy[] = {0, 0, 1, -1};",
            "",
            "void sol(int tc)",
            "{",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "",
            "    int T = 1;",
            "    ${1://} cin >> T;",
            "    for (int ii = 1; ii <= T; ++ii)",
            "        sol(ii);",
            "}",
            "",
            ""
        ],
        "description": "Template"
    },
    "Template": {
        "prefix": "fja",
        "body": [
            "",
            "// Knightshade -> $TM_FILENAME",
            "// Date $CURRENT_YEAR:$CURRENT_MONTH:$CURRENT_DATE Time $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "",
            "#include <bits/stdc++.h>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "#define sync                     \\",
            "    ios::sync_with_stdio(false); \\",
            "    cin.tie(nullptr);",
            "",
            "#define files                        \\",
            "    freopen(\"input.txt\", \"r\", stdin); \\",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "",
            "template <typename T>",
            "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "template <typename T>",
            "using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "template <typename T>",
            "using min_heap = priority_queue<T, vector<T>, greater<T>>;",
            "",
            "#define rep(ii, beg, till, inc) for (int ii = beg; ii < till; ii += inc)",
            "#define repr(ii, beg, till, inc) for (int ii = beg - 1; ii >= till; ii -= inc)",
            "#define repa(ii, tem) for (auto ii : tem)",
            "",
            "#define ll long long",
            "#define ull unsigned long long",
            "",
            "#define sz(x) (int)x.size()",
            "#define all(x) x.begin(), x.end()",
            "#define rall(x) x.rbegin(), x.rend()",
            "",
            "const ll MOD = 1e9 + 7;",
            "const int MXN = 2e5 + 5;",
            "",
            "const ll bPrime = 998244353;",
            "const int infi = 2e9;",
            "const double eps = 1e-9;",
            "",
            "#define no cout << \"No\\n\"",
            "#define NO cout << \"NO\\n\"",
            "",
            "#define yes cout << \"Yes\\n\"",
            "#define YES cout << \"YES\\n\"",
            "",
            "#define tcase(x) cout << \"Case \" << x << \": \"",
            "#define prec(x) cout << fixed << setprecision(x)",
            "#define watch(x) cerr << (#x) << \" => \" << (x) << '\\n'",
            "",
            "int dx[] = {1, -1, 0, 0};",
            "int dy[] = {0, 0, 1, -1};",
            "",
            "int dx8[] = {0, 0, 1, 1, 1, -1, -1, -1};",
            "int dy8[] = {1, -1, 1, -1, 0, 0, -1, 1};",
            "",
            "int two[32];",
            "ll fact[MXN];",
            "",
            "#define two() rep(ii, two[0] = 1, 31) two[ii] = two[ii - 1] * 2",
            "#define fact() rep(ii, fact[0] = 1, MXN) fact[ii] = fact[ii - 1] * ii % MOD",
            "",
            "",
            "void sol(int tc)",
            "{",
            "}",
            "",
            "int main()",
            "{",
            "    sync;",
            "    int tc = 1;",
            "    ${1://} cin >> tc;",
            "    for (int ii = 1; ii <= tc; ++ii)",
            "        sol(ii);",
            "}",
            "",
            ""
        ],
        "description": "Template"
    },
    "Policy Based DS": {
        "prefix": "pbds",
        "body": [
            "",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template <typename T>",
            "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            ""
        ],
        "description": "Policy Based DS"
    },
    "Bridge by dfs tree , blog by -is-this-fft-": {
        "prefix": "bridge",
        "body": [
            "vector<pair<int, int>> bridge;",
            "vector<int> g[MXN], b(MXN), in(MXN), vis(MXN);",
            "",
            "int dfs(int node, int par = 0)",
            "{",
            "    vis[node] = 1;",
            "    in[node] = in[par] + 1;",
            "    for (int child : g[node])",
            "    {",
            "        if (child == par)",
            "            continue;",
            "        if (vis[child])",
            "        {",
            "            b[node] += (in[node] > in[child] ? 1 : -1);",
            "            continue;",
            "        }",
            "        b[node] += dfs(child, node);",
            "    }",
            "    if (b[node] == 0 && par != 0)",
            "        bridge.push_back({min(node, par), max(node, par)});",
            "    return b[node];",
            "}"
        ],
        "description": "Bridge by dfs tree , blog by -is-this-fft-"
    },
    "Binary Exponention": {
        "prefix": "binpow",
        "body": [
            "/*",
            " *   1. if M is a prime : binPow(base , pow) == binPow(base, pow % (M - 1)), base ^ pow = base ^ (pow % (M - 1)) (%M)",
            " *   2. if M is a prime : binPow(base, M - 2) == a ^ -1 (modular multiplicative inverse of base)",
            " *   3. To calculate a * b % M with overflow issues : just do ans = 0 and ans = (ans + base) % M and",
            " *      base = (2 * base) % M and explaination to that method :",
            " *      we can do a * b = a + a + ... b times or just 8a = 2 * 4a = 4 * 2a.",
            " */",
            "long long bin(long long base, long long pow, long long m)",
            "{",
            "    if (base >= m)",
            "        base %= m;",
            "    long long res = 1;",
            "    while (pow)",
            "    {",
            "        if (pow & 1)",
            "        {",
            "            res = res * base;",
            "            if (res >= m)",
            "                res %= m;",
            "        }",
            "        base = base * base;",
            "        if (base >= m)",
            "            base %= m;",
            "        pow >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponention"
    },
    "Sieve": {
        "prefix": "sieve",
        "body": [
            "vector<int> prime;",
            "vector<char> isPrime;",
            "void sieve(int n)",
            "{",
            "    isPrime.resize(n + 1);",
            "    if (n >= 2)",
            "        prime.push_back(2);",
            "    for (int ii = 3; ii <= n; ii += 2)",
            "    {",
            "        if (isPrime[ii])",
            "            continue;",
            "        prime.push_back(ii);",
            "        if (1LL * ii * ii > 1LL * n)",
            "            continue;",
            "        for (int jj = ii * ii; jj <= n; jj += 2 * ii)",
            "            isPrime[jj] = true;",
            "    }",
            "    return;",
            "}"
        ],
        "description": "Sieve"
    },
    "Extended Euclid": {
        "prefix": "exgcd",
        "body": [
            "/*",
            " *   1. it returns x and y for ax + by = gcd(a, b)",
            " *   2. proof (b % a)x1 + ay1 = gcd",
            " *      => (b - b / a * a)x1 + ay1 = gcd",
            " *      => bx1 + a(y1 - b / a * x1) = gcd",
            " *      => x = y1 - b / a * x1 , y = x1",
            " */",
            "long long exEuclid(long long a, long long b, long long &x, long long &y)",
            "{",
            "    if (a == 0)",
            "    {",
            "        x = 0;",
            "        y = 1;",
            "        return b;",
            "    }",
            "    long long x1, y1;",
            "    long long gcd = exEuclid(b % a, a, x1, y1);",
            "    x = y1 - b / a * x1;",
            "    y = x1;",
            "    return gcd;",
            "}"
        ],
        "description": "Extended Euclid"
    },
    "Modular inverse": {
        "prefix": "modinv",
        "body": [
            "/*",
            " *   1. it returns x and y for ax + by = gcd(a, b)",
            " *   2. proof (b % a)x1 + ay1 = gcd",
            " *      => (b - b / a * a)x1 + ay1 = gcd",
            " *      => bx1 + a(y1 - b / a * x1) = gcd",
            " *      => x = y1 - b / a * x1 , y = x1",
            " */",
            "long long exEuclid(long long a, long long b, long long &x, long long &y)",
            "{",
            "    if (a == 0)",
            "    {",
            "        x = 0;",
            "        y = 1;",
            "        return b;",
            "    }",
            "    long long x1, y1;",
            "    long long gcd = exEuclid(b % a, a, x1, y1);",
            "    x = y1 - b / a * x1;",
            "    y = x1;",
            "    return gcd;",
            "}",
            "/*",
            " *   1. ax + my == 1 (% M)",
            " *    = ax == 1 (% M)",
            " *    where x ==  a ^ -1",
            " */",
            "long long modInv(long long a, long long m)",
            "{",
            "    if (a == 0)",
            "        return 1;",
            "    long long x, y;",
            "    long long gcd = exEuclid(a, m, x, y);",
            "    if (gcd != 1)",
            "        return -1;",
            "    return (x % m + m) % m;",
            "}"
        ],
        "description": "Modular inverse"
    },
    "Linear Congruence": {
        "prefix": "linear con",
        "body": [
            "/*",
            " *   1. it returns x and y for ax + by = gcd(a, b)",
            " *   2. proof (b % a)x1 + ay1 = gcd",
            " *      => (b - b / a * a)x1 + ay1 = gcd",
            " *      => bx1 + a(y1 - b / a * x1) = gcd",
            " *      => x = y1 - b / a * x1 , y = x1",
            " */",
            "long long exEuclid(long long a, long long b, long long &x, long long &y)",
            "{",
            "    if (a == 0)",
            "    {",
            "        x = 0;",
            "        y = 1;",
            "        return b;",
            "    }",
            "    long long x1, y1;",
            "    long long gcd = exEuclid(b % a, a, x1, y1);",
            "    x = y1 - b / a * x1;",
            "    y = x1;",
            "    return gcd;",
            "}",
            "/*",
            " *   1. ax + my == 1 (% M)",
            " *    = ax == 1 (% M)",
            " *    where x ==  a ^ -1",
            " */",
            "long long modInv(long long a, long long m)",
            "{",
            "    if (a == 0)",
            "        return 1;",
            "    long long x, y;",
            "    long long gcd = exEuclid(a, m, x, y);",
            "    if (gcd != 1)",
            "        return -1;",
            "    return (x % m + m) % m;",
            "}",
            "/*",
            " *   1. Linear congruence equation => ax == b (% M)",
            " *   2. if M and a are co-prime then x = b * a ^ -1 (% M)",
            " *   3. else if b is not divisible by gcd(a, M) there is no sol else",
            " *      divide a, b, M by gcd and we get a'x == b' (% M') equation where a' and M'",
            " *      are already co-prime! make sure M is not \"const\"*.",
            " *   4. if b is divisible by gcd then there is gcd number of sol.",
            " */",
            "vector<long long> linearConEqu(long long a, long long b, long long m)",
            "{",
            "    long long gcd = __gcd(a, m);",
            "    vector<long long> sols;",
            "    if (b % gcd)",
            "        return sols;",
            "    // Make sure m is not const",
            "    a /= gcd;",
            "    b /= gcd;",
            "    m /= gcd;",
            "    long long x = modInv(a, m) * b % m;",
            "    for (long long ii = 0; ii < gcd; ++ii)",
            "    {",
            "        long long add = x + ii * m;",
            "        sols.push_back(add);",
            "    }",
            "    return sols;",
            "}"
        ],
        "description": "Linear Congruence"
    },
    "phi function": {
        "prefix": "phi",
        "body": [
            "/*",
            " *   1. if p is a prime and k any integer then : p ^ k / p = p ^ (k - 1) numbers are devided by p",
            " *      from 1 to p ^ k, hence total co-primes : p ^ k - p ^ (k - 1)",
            " *   2. if a and b are co-prime : phi(ab) = phi(a) * phi (b) => from chinese remainder theorem!",
            " *   3. if a and b are NOT CO-PRIME : phi(ab) = phi(a) * phi(b) * gcd(a, b) / phi(gcd(a, b))",
            " *   4. so we can derive equation for phi from these by prime factorizing the numbers with power :",
            " *   phi(n) = phi(p1 ^ a1) * phi(p2 ^ a2) * phi(p3 ^ a3).....",
            " *          = (p1 ^ a1 - p1 ^ (a1 - 1)) * (p2 ^ a2 - p2 ^ (a2 - 1)) * (p3 ^ a3 - p3^ (a3 - 1))....",
            " *          = p1 ^ a1 * (1 - 1 / p1) * p2 ^ a2 * (1 - 1 / p2).........",
            " *          = n * (1 - 1 / p1) * (1 - 1 / p2)......",
            " *",
            " *   5. a ^ phi(M) == 1 (% M)",
            " *    = a ^ (phi(M) - 1) == a ^ -1 (% M)",
            " *   6. if a and M are co-prime a ^ n == a ^ (n % phi(M)) (%M)",
            " *      else a ^ (phi(M) + n % phi(M)) % M == a ^ n % M",
            " *",
            " *** NOD",
            " *   1.  a divisor must be a subset of prime factorization and for a prime with power p ^ e can contribute like",
            " *       (e + 1) subset that is p ^ 0 .... P ^ e thus NOD = (e + 1) * (f + 1) * (g + 1) * ...",
            " *** SOD",
            " *   1. sum of devisor must be sum of all subset of prime factorization",
            " *      so (p1 ^0 + ...+ p1 ^ e) * (p2 ^ 0 + .... + p2 ^ f) * ....",
            " *      = (p1 ^ (e +  1) - 1) / (p1 - 1) * (p2 ^ (f + 1) - 1) / (p2 - 1) * ....",
            " */",
            "int phi(int n)",
            "{",
            "    int res = n;",
            "    for (int ii = 2; ii <= n / ii; ii += 2)",
            "    {",
            "        if (n % ii == 0)",
            "        {",
            "            while (n % ii == 0)",
            "                n /= ii;",
            "            res -= res / ii;",
            "        }",
            "        if (ii == 2)",
            "            --ii;",
            "    }",
            "    if (n != 1)",
            "        res -= res / n;",
            "    return res;",
            "}"
        ],
        "description": "phi function"
    },
    "Catalan Number": {
        "prefix": "catalan",
        "body": [
            "/*",
            "*   1. valid bracket sequence",
            "*   2. how many ways a polygon of n sides could be triangulate",
            "*   3. number of complete binary tree of n nodes",
            "*   4  The number of monotonic lattice paths from point (0, 0) to point (n, n) in",
            "*      a square lattice of size n Ã— n, which do not pass above the main diagonal",
            "*   5. The number of non-crossing partitions of a set of n elements",
            "*   6. The number of ways to cover the ladder 1 . . . n using n rectangles (The",
            "       ladder consists of n columns, where ith column has a height i)",
            "*   7. The number of ways to connect the 2n points on a circle to form n disjoint chords",
            "*   *** anwere to the all is the catalan number!",
            "*   8. recurrence relation cn = sumation (fron k = 0 to n - 1) ck * c (n - k - 1)",
            "*   9, cn =  (2n , n) / (n + 1) = (2n , n) - (2n, n - 1)",
            "*/",
            "class Catalan",
            "{",
            "public:",
            "    long long catalanNum[MXN];",
            "    void catalan(int n)",
            "    {",
            "        catalanNum[0] = catalanNum[1] = 1;",
            "        for (int ii = 2; ii <= n; ++ii)",
            "        {",
            "            for (int jj = 0; jj < ii; ++jj)",
            "            {",
            "                catalanNum[ii] += catalanNum[jj] * catalanNum[ii - jj - 1];",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Catalan Number"
    },
    "Segment Tree": {
        "prefix": "seg",
        "body": [
            "template <class T>",
            "class SegmentTree",
            "{",
            "public:",
            "    vector<T> segTree;",
            "",
            "    SegmentTree(int n)",
            "    {",
            "        segTree.resize(4 * n);",
            "    }",
            "",
            "    T work(T x, T y)",
            "    {",
            "        return x + y;",
            "    }",
            "",
            "    void build(T every, int id, int left, int right)",
            "    {",
            "        if (left == right)",
            "        {",
            "            segTree[id] = every;",
            "            return;",
            "        }",
            "        int mid = (left + right) / 2;",
            "        build(every, id * 2, left, mid);",
            "        build(every, id * 2 + 1, mid + 1, right);",
            "        segTree[id] = work(segTree[2 * id], segTree[2 * id + 1]);",
            "    }",
            "",
            "    void build(vector<T> &x, int id, int left, int right)",
            "    {",
            "        if (left == right)",
            "        {",
            "            segTree[id] = x[left];",
            "            return;",
            "        }",
            "        int mid = (left + right) / 2;",
            "        build(x, id * 2, left, mid);",
            "        build(x, id * 2 + 1, mid + 1, right);",
            "        segTree[id] = work(segTree[2 * id], segTree[2 * id + 1]);",
            "    }",
            "",
            "    T query(int id, int left, int right, int l, int r)",
            "    {",
            "        if (l > r)",
            "            return 0;",
            "        if (left == l && right == r)",
            "            return segTree[id];",
            "        int mid = (left + right) / 2;",
            "        T x = query(2 * id, left, mid, l, min(mid, r));",
            "        T y = query(2 * id + 1, mid + 1, right, max(mid + 1, l), r);",
            "        return work(x, y);",
            "    }",
            "",
            "    void update(int id, int left, int right, int pos, T val)",
            "    {",
            "        if (left == right)",
            "        {",
            "            segTree[id] = val;",
            "            return;",
            "        }",
            "        int mid = (left + right) / 2;",
            "        if (pos <= mid)",
            "            update(id * 2, left, mid, pos, val);",
            "        else",
            "            update(id * 2 + 1, mid + 1, right, pos, val);",
            "        segTree[id] = work(segTree[id * 2], segTree[id * 2 + 1]);",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "Mo's algorithm": {
        "prefix": "mo",
        "body": [
            "int block;",
            "struct Query",
            "{",
            "    int left, right, idx;",
            "    bool operator<(Query other) const",
            "    {",
            "        if (left / block != other.left / block)",
            "            return left < other.left;",
            "        return (left / block) % 2 ? right > other.right : right < other.right;",
            "    }",
            "};"
        ],
        "description": "Mo's algorithm"
    },
    "Sparse Table": {
        "prefix": "sparse",
        "body": [
            "template <typename T>",
            "class SparseTable",
            "{",
            "public:",
            "    vector<T> lg, two;",
            "    vector<vector<T>> st;",
            "",
            "    void build(vector<int> &aa, int state)",
            "    {",
            "        int n = pre.size();",
            "        lg.resize(n + 1);",
            "        two.resize(n + 1);",
            "        lg[0] = lg[1] = 0;",
            "",
            "        for (int ii = 2; ii <= n; ++ii)",
            "            lg[ii] = lg[ii / 2] + 1;",
            "        for (int ii = two[0] = 1; ii <= n; ++ii)",
            "            two[ii] = two[ii - 1] * 2;",
            "",
            "        st.resize(n, vector<T>(lg[n] + 1));",
            "        for (int ii = 0; ii < n; ii++)",
            "            st[ii][0] = aa[ii];",
            "        for (int jj = 1; jj <= lg[n]; jj++)",
            "            for (int ii = 0; ii + two[jj] <= n; ii++)",
            "            {",
            "                T x = st[ii][jj - 1];",
            "                T y = st[ii + two[jj - 1]][jj - 1];",
            "                st[ii][jj] = state ? max(x, y) : min(x, y);",
            "            };",
            "    }",
            "",
            "    T query(int L, int R, int state)",
            "    {",
            "        int jj = lg[(R - L + 1)];",
            "        T x = st[L][jj];",
            "        T y = st[R - two[jj] + 1][jj];",
            "        return state ? max(x, y) : min(x, y);",
            "    }",
            "};"
        ],
        "description": "Sparse Table"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "class KMP",
            "{",
            "public:",
            "    vector<int> pi;",
            "    void kmp(string s)",
            "    {",
            "        int n = (int)s.size();",
            "        pi.resize(n);",
            "        pi[0] = 0;",
            "        for (int ii = 1; ii < n; ++ii)",
            "        {",
            "            int jj = pi[ii - 1];",
            "            while (jj > 0 && s[ii] != s[jj])",
            "                jj = pi[jj - 1];",
            "            if (s[ii] == s[jj])",
            "                ++jj;",
            "            pi[ii] = jj;",
            "        }",
            "    }",
            "};"
        ],
        "description": "kmp"
    },
    "Aho corasick": {
        "prefix": "aho",
        "body": [
            "// Aho-Corasick",
            "struct Node",
            "{",
            "public:",
            "    int par;",
            "    int leaf = 0;",
            "    char parChar;",
            "    int link = -1;",
            "    int go[26];",
            "    int edges[26];",
            "    Node(int _par = 0, char _parChar = '$') : par(_par), parChar(_parChar)",
            "    {",
            "        for (int ii = 0; ii < 26; ++ii)",
            "            edges[ii] = go[ii] = -1;",
            "    }",
            "};",
            "vector<Node> Trie;",
            "vector<long long> points;",
            "// add new string. if any transition not possible makes new node.",
            "void addString(string s)",
            "{",
            "    int root = 0;",
            "    for (char ch : s)",
            "    {",
            "        int cur = ch - 'a';",
            "        if (Trie[root].edges[cur] == -1)",
            "        {",
            "            Trie[root].edges[cur] = Trie.size();",
            "            Trie.emplace_back(root, ch);",
            "        }",
            "        root = Trie[root].edges[cur];",
            "    }",
            "    Trie[root].leaf++;",
            "}",
            "// gives you the node with current string ending. Must be in given string or custom the function",
            "int findString(string s)",
            "{",
            "    int root = 0;",
            "    for (char ch : s)",
            "    {",
            "        int cur = ch - 'a';",
            "        root = Trie[root].edges[cur];",
            "    }",
            "    return root;",
            "}",
            "int goLink(int root, char curChar);",
            "// find the suffix / failure link",
            "int findLink(int root)",
            "{",
            "    if (Trie[root].link == -1)",
            "    {",
            "        if (root == 0 || Trie[root].par == 0)",
            "        {",
            "            Trie[root].link = 0;",
            "        }",
            "        else",
            "        {",
            "            Trie[root].link = goLink(findLink(Trie[root].par), Trie[root].parChar);",
            "        }",
            "    }",
            "    return Trie[root].link;",
            "}",
            "// automaton next transition with some character",
            "int goLink(int root, char curChar)",
            "{",
            "    int cur = curChar - 'a';",
            "    if (Trie[root].go[cur] == -1)",
            "    {",
            "        if (Trie[root].edges[cur] != -1)",
            "        {",
            "            Trie[root].go[cur] = Trie[root].edges[cur];",
            "        }",
            "        else",
            "        {",
            "            Trie[root].go[cur] = root == 0 ? 0 : goLink(findLink(root), curChar);",
            "        }",
            "    }",
            "    return Trie[root].go[cur];",
            "}"
        ],
        "description": "Aho corasick"
    },
    "Suffix Array": {
        "prefix": "suffix",
        "body": [
            "class SuffixArray",
            "{",
            "public:",
            "    vector<int> sort_cyclic_shifts(string const &s)",
            "    {",
            "        int n = s.size();",
            "        const int alphabet = 256;",
            "        vector<int> p(n), c(n), cnt(max(alphabet, n), 0);",
            "        for (int i = 0; i < n; i++)",
            "            cnt[s[i]]++;",
            "        for (int i = 1; i < alphabet; i++)",
            "            cnt[i] += cnt[i - 1];",
            "        for (int i = 0; i < n; i++)",
            "            p[--cnt[s[i]]] = i;",
            "        c[p[0]] = 0;",
            "        int classes = 1;",
            "        for (int i = 1; i < n; i++)",
            "        {",
            "            if (s[p[i]] != s[p[i - 1]])",
            "                classes++;",
            "            c[p[i]] = classes - 1;",
            "        }",
            "        vector<int> pn(n), cn(n);",
            "        for (int h = 0; (1 << h) < n; ++h)",
            "        {",
            "            for (int i = 0; i < n; i++)",
            "            {",
            "                pn[i] = p[i] - (1 << h);",
            "                if (pn[i] < 0)",
            "                    pn[i] += n;",
            "            }",
            "            fill(cnt.begin(), cnt.begin() + classes, 0);",
            "            for (int i = 0; i < n; i++)",
            "                cnt[c[pn[i]]]++;",
            "            for (int i = 1; i < classes; i++)",
            "                cnt[i] += cnt[i - 1];",
            "            for (int i = n - 1; i >= 0; i--)",
            "                p[--cnt[c[pn[i]]]] = pn[i];",
            "            cn[p[0]] = 0;",
            "            classes = 1;",
            "            for (int i = 1; i < n; i++)",
            "            {",
            "                pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};",
            "                pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};",
            "                if (cur != prev)",
            "                    ++classes;",
            "                cn[p[i]] = classes - 1;",
            "            }",
            "            c.swap(cn);",
            "        }",
            "        return p;",
            "    }",
            "    vector<int> lcp_construction(string const &s, vector<int> const &p)",
            "    {",
            "        int n = s.size();",
            "        vector<int> rank(n, 0);",
            "        for (int i = 0; i < n; i++)",
            "            rank[p[i]] = i;",
            "",
            "        int k = 0;",
            "        vector<int> lcp(n - 1, 0);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            if (rank[i] == n - 1)",
            "            {",
            "                k = 0;",
            "                continue;",
            "            }",
            "            int j = p[rank[i] + 1];",
            "            while (i + k < n && j + k < n && s[i + k] == s[j + k])",
            "                k++;",
            "            lcp[rank[i]] = k;",
            "            if (k)",
            "                k--;",
            "        }",
            "        return lcp;",
            "    }",
            "    vector<int> p, lcp;",
            "    void work(string s)",
            "    {",
            "        p.clear();",
            "        lcp.clear();",
            "",
            "        s += '$';",
            "        p = sort_cyclic_shifts(s);",
            "        lcp = lcp_construction(s, p);",
            "        p.erase(p.begin());",
            "    }",
            "};"
        ],
        "description": "Suffix Array"
    },
    "convex hull": {
        "prefix": "convex",
        "body": [
            "struct pt",
            "{",
            "    double x, y;",
            "};",
            "int orientation(pt a, pt b, pt c)",
            "{",
            "    double v = a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);",
            "    if (v < 0)",
            "        return -1; // clockwise",
            "    if (v > 0)",
            "        return +1; // counter-clockwise",
            "    return 0;",
            "}",
            "bool cw(pt a, pt b, pt c, bool include_collinear)",
            "{",
            "    int o = orientation(a, b, c);",
            "    return o < 0 || (include_collinear && o == 0);",
            "}",
            "bool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }",
            "void convex_hull(vector<pt> &a, bool include_collinear = false)",
            "{",
            "    pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b)",
            "                         { return make_pair(a.y, a.x) < make_pair(b.y, b.x); });",
            "    sort(a.begin(), a.end(), [&p0](const pt &a, const pt &b)",
            "         {",
            "        int o = orientation(p0, a, b);",
            "        if (o == 0)",
            "            return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)",
            "                < (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);",
            "        return o < 0; });",
            "    if (include_collinear)",
            "    {",
            "        int i = (int)a.size() - 1;",
            "        while (i >= 0 && collinear(p0, a[i], a.back()))",
            "            i--;",
            "        reverse(a.begin() + i + 1, a.end());",
            "    }",
            "    vector<pt> st;",
            "    for (int i = 0; i < (int)a.size(); i++)",
            "    {",
            "        while (st.size() > 1 && !cw(st[st.size() - 2], st.back(), a[i], include_collinear))",
            "            st.pop_back();",
            "        st.push_back(a[i]);",
            "    }",
            "    a = st;",
            "}"
        ],
        "description": "convex hull"
    },
    "binary lifting": {
        "prefix": "binary lifting",
        "body": [
            "int n, l;",
            "vector<vector<int>> adj;",
            "int timer;",
            "vector<int> tin, tout;",
            "vector<vector<int>> up;",
            "void dfs(int v, int p)",
            "{",
            "    tin[v] = ++timer;",
            "    up[v][0] = p;",
            "    for (int i = 1; i <= l; ++i)",
            "        up[v][i] = up[up[v][i - 1]][i - 1];",
            "    for (int u : adj[v])",
            "    {",
            "        if (u != p)",
            "            dfs(u, v);",
            "    }",
            "    tout[v] = ++timer;",
            "}",
            "bool is_ancestor(int u, int v)",
            "{",
            "    return tin[u] <= tin[v] && tout[u] >= tout[v];",
            "}",
            "int lca(int u, int v)",
            "{",
            "    if (is_ancestor(u, v))",
            "        return u;",
            "    if (is_ancestor(v, u))",
            "        return v;",
            "    for (int i = l; i >= 0; --i)",
            "    {",
            "        if (!is_ancestor(up[u][i], v))",
            "            u = up[u][i];",
            "    }",
            "    return up[u][0];",
            "}",
            "void init(int root)",
            "{",
            "    tin.resize(n);",
            "    tout.resize(n);",
            "    timer = 0;",
            "    l = ceil(log2(n));",
            "    up.assign(n, vector<int>(l + 1));",
            "    dfs(root, root);",
            "}"
        ],
        "description": "binary lifting"
    },
    "Tarjan": {
        "prefix": "tarjan",
        "body": [
            "vector<vector<int>> adj;",
            "vector<vector<int>> queries;",
            "vector<int> ancestor;",
            "vector<bool> visited;",
            "void dfs(int v)",
            "{",
            "    visited[v] = true;",
            "    ancestor[v] = v;",
            "    for (int u : adj[v])",
            "    {",
            "        if (!visited[u])",
            "        {",
            "            dfs(u);",
            "            // union_sets(v, u);",
            "            // ancestor[find_set(v)] = v;",
            "        }",
            "    }",
            "    for (int other_node : queries[v])",
            "    {",
            "        // if (visited[other_node])",
            "        //     cout << \"LCA of \" << v << \" and \" << other_node",
            "        //          << \" is \" << ancestor[find_set(other_node)] << \".\\n\";",
            "    }",
            "}",
            "void compute_LCAs()",
            "{",
            "    ancestor.resize(n);",
            "    visited.assign(n, false);",
            "    dfs(0);",
            "}"
        ],
        "description": "Tarjan"
    },
    "Hash": {
        "prefix": "polyhash",
        "body": [
            "class Hash",
            "{",
            "public:",
            "    long long prime, mod;",
            "    vector<long long> power;",
            "    vector<long long> fhash, rhash;",
            "",
            "    void f_hash(string s, long long _prime, long long _mod)",
            "    {",
            "        prime = _prime;",
            "        mod = _mod;",
            "",
            "        int len = sz(s);",
            "        len = max(len, sz(power));",
            "        fhash.resize(len + 5);",
            "        power.resize(len + 5);",
            "        power[0] = 1;",
            "",
            "        for (int ii = 0; ii < len; ++ii)",
            "        {",
            "            fhash[ii] = (s[ii] - 'a' + 1) * power[ii];",
            "            if (fhash[ii] >= mod)",
            "                fhash[ii] %= mod;",
            "            if (ii != 0)",
            "            {",
            "                fhash[ii] += fhash[ii - 1];",
            "                if (fhash[ii] >= mod)",
            "                    fhash[ii] -= mod;",
            "            }",
            "            power[ii + 1] = power[ii] * prime;",
            "            if (power[ii + 1] >= mod)",
            "                power[ii + 1] %= mod;",
            "        }",
            "    }",
            "",
            "    void r_hash(string s, long long _prime, long long _mod)",
            "    {",
            "        prime = _prime;",
            "        mod = _mod;",
            "",
            "        int len = sz(s);",
            "        len = max(len, sz(power));",
            "        rhash.resize(len + 5);",
            "        power.resize(len + 5);",
            "        power[0] = 1;",
            "",
            "        for (int ii = 0; ii < len; ++ii)",
            "        {",
            "            rhash[ii] = 0;",
            "            if (ii != 0)",
            "            {",
            "                rhash[ii] = rhash[ii - 1] * prime;",
            "                if (rhash[ii] >= mod)",
            "                    rhash[ii] %= mod;",
            "            }",
            "            rhash[ii] += (s[ii] - 'a' + 1);",
            "            if (rhash[ii] >= mod)",
            "                rhash[ii] -= mod;",
            "            power[ii + 1] = power[ii] * prime;",
            "            if (power[ii + 1] >= mod)",
            "                power[ii + 1] %= mod;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Hash"
    },
    "Fenwick Tree": {
        "prefix": "bit",
        "body": [
            "template <class T>",
            "class FenwickTree",
            "{",
            "public:",
            "    FenwickTree(int n)",
            "    {",
            "        this->n = n;",
            "        bit.assign(n + 1, 0);",
            "    }",
            "",
            "    FenwickTree(vector<T> &a)",
            "    {",
            "        n = a.size();",
            "        bit.assign(n + 1, 0);",
            "        for (int i = 1; i <= n; i++)",
            "        {",
            "            bit[i] += a[i - 1];",
            "            if (i + (i & -i) <= n)",
            "            {",
            "                bit[i + (i & -i)] += bit[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    T query(int x)",
            "    {",
            "        x = min(x, (int)bit.size() - 1);",
            "        T ans = 0;",
            "        for (; x > 0; x -= x & -x)",
            "        {",
            "            ans += bit[x];",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    void update(int x, T v)",
            "    {",
            "        if (x <= 0)",
            "            return;",
            "        for (; x <= n; x += x & -x)",
            "        {",
            "            bit[x] += v;",
            "        }",
            "    }",
            "",
            "private:",
            "    int n;",
            "    vector<T> bit;",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Debug": {
        "prefix": "debug",
        "body": [
            "",
            "vector<string> vec_splitter(string s)",
            "{",
            "    s += ',';",
            "    vector<string> res;",
            "    while (!s.empty())",
            "    {",
            "        res.push_back(s.substr(0, s.find(',')));",
            "        s = s.substr(s.find(',') + 1);",
            "    }",
            "    return res;",
            "}",
            "",
            "void debug_out(",
            "    vector<string> __attribute__((unused)) args,",
            "    __attribute__((unused)) int idx,",
            "    __attribute__((unused)) int LINE_NUM) { cerr << endl; }",
            "",
            "template <typename Head, typename... Tail>",
            "void debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T)",
            "{",
            "    if (idx > 0)",
            "        cerr << \", \";",
            "    else",
            "        cerr << \"Line(\" << LINE_NUM << \") \";",
            "    stringstream ss;",
            "    ss << H;",
            "    cerr << args[idx] << \" = \" << ss.str();",
            "    debug_out(args, idx + 1, LINE_NUM, T...);",
            "}",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define debug(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)",
            "#else",
            "#define debug(...) 42",
            "#endif",
            ""
        ],
        "description": "Debug"
    },
    "manachar": {
        "prefix": "manachar",
        "body": [
            "",
            "// # calculates maximum palindromic substring from each index in O(N)",
            "// # from all index odd length palindromes are calculated",
            "// # to calculate even length palindromes we modified string with dummy character '#'",
            "// # actual length of palindromic substring (r - l + 1) / 2",
            "// # in a range s[l] .s[i]. . .s[j]. s[r] , index j is the position symmetrical to i",
            "",
            "void manachar(int N, string &s)",
            "{",
            "    string pal = \"#\";",
            "    rep(ii, 0, N, 1) pal += s[ii], pal += '#';",
            "",
            "    N = sz(pal);",
            "    vector<int> len(N);",
            "",
            "    int l = -1, r = -1;",
            "    rep(ii, 0, N, 1)",
            "    {",
            "        int cur = r < ii ? 1 : min(r - ii, len[l + r - ii]);",
            "        while (0 <= ii - cur && ii + cur < N && pal[ii - cur] == pal[ii + cur])",
            "            ++cur;",
            "        len[ii] = --cur;",
            "        if (r < ii + cur)",
            "        {",
            "            l = ii - cur;",
            "            r = ii + cur;",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "manachar"
    },
    "Fast Sieve": {
        "prefix": "seive",
        "body": [
            "template <int N = 1'000'000, bool compute_primes = true>",
            "struct fast_sieve",
            "{",
            "    std::bitset<N / 3 + 1> sieve;",
            "    vector<int> primes;",
            "    inline bool is_prime(int n)",
            "    {",
            "        return n == 2 || n == 3 || ((n & 1) && (n % 3) && (sieve[n / 3]));",
            "    }",
            "    void fill_sieve()",
            "    {",
            "        sieve.set();",
            "        for (int p = 5, d = 4, i = 1, sqn = int(std::sqrt(N)); p <= sqn;",
            "             p += d = 6 - d, i++)",
            "        {",
            "            if (!sieve[i])",
            "                continue;",
            "            for (int q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p,",
            "                     qe = (int)sieve.size();",
            "                 q < qe; q += r = s - r)",
            "                sieve[q] = 0;",
            "        }",
            "    }",
            "    vector<int> get_primes()",
            "    {",
            "        vector<int> ret{2, 3};",
            "        for (int p = 5, d = 4, i = 1; p <= N; p += d = 6 - d, i++)",
            "            if (sieve[i])",
            "                ret.push_back(p);",
            "        while (!ret.empty() && ret.back() > N)",
            "            ret.pop_back();",
            "        return ret;",
            "    }",
            "    fast_sieve()",
            "    {",
            "        fill_sieve();",
            "        if (compute_primes)",
            "            primes = get_primes();",
            "    }",
            "};"
        ],
        "description": "Fast Sieve"
    },
    "LCS BITSET": {
        "prefix": "LCS",
        "body": [
            "#pragma GCC optimize(\"Ofast\")",
            "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")",
            "#pragma GCC optimize(\"unroll-loops\")",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "/* Bit-String Longest Common Subsequence Algorithm",
            "O(nm/w)*/",
            "const int N = 5e4 + 9, SIGMA = 26;",
            "const int W = 62;",
            "int M;",
            "struct Bitset {",
            "    long long u[N / W + 5];",
            "    void clear() {",
            "        memset(u, 0, sizeof(u));",
            "    }",
            "    void set(int x) {",
            "        u[x / W] |= 1ll << (x % W);",
            "    }",
            "    Bitset operator | (const Bitset &r) const {",
            "        Bitset s;",
            "        for (int i = 0; i < M; ++ i) {",
            "            s.u[i] = u[i] | r.u[i];",
            "        }",
            "        return s;",
            "    }",
            "    void yo(const Bitset &r) {",
            "        for (int i = 0; i < M; ++ i) {",
            "            u[i] = (u[i] ^ r.u[i]) & r.u[i];",
            "        }",
            "    }",
            "    void sub(const Bitset &r) {",
            "        for (int i = 0; i < M; ++ i) u[i] = r.u[i] - u[i];",
            "        for (int i = 0; i < M; ++ i) if (u[i] < 0) {",
            "                u[i] += 1ll << W;",
            "                u[i + 1] --;",
            "            }",
            "    }",
            "    void shl() {",
            "        long long c = 1;",
            "        for (long i = 0; i < M; ++ i) {",
            "            u[i] <<= 1;",
            "            u[i] |= c;",
            "            c = u[i] >> W & 1;",
            "            u[i] ^= c << W;",
            "        }",
            "    }",
            "    int count() const {",
            "        int c = 0;",
            "        for (int i = 0; i < M; ++ i) {",
            "            c += __builtin_popcountll(u[i]);",
            "        }",
            "        return c;",
            "    }",
            "} row, bs[SIGMA], x;",
            "int main() {",
            "    for (int i = 0; i < SIGMA; ++i) bs[i].clear();",
            "    string s, t;",
            "    cin >> s >> t;",
            "    int n = s.size(), m = t.size();",
            "    for (int i = 0; i < n; ++ i) {",
            "        bs[s[i] - 'a'].set(i);",
            "    }",
            "    M = n / W + (n % W != 0);",
            "    row.clear();",
            "    for (int i = 0; i < m; ++i) {",
            "        for (int j = 0; j < M; ++j) {",
            "            x.u[j] = row.u[j] | bs[t[i] - 'a'].u[j];",
            "        }",
            "        row.shl();",
            "        row.sub(x);",
            "        row.yo(x);",
            "        //printf(\"%d\\n\", row.count()); //lcs of prefix of t and whole s",
            "    }",
            "    cout << row.count() << '\\n';",
            "    return 0;",
            "}",
            "//https://www.spoj.com/problems/LCS0/"
        ],
        "description": "LCS BITSET"
    },
    "Bitset Memory Efficient": {
        "prefix": "bitset",
        "body": [
            "struct Bitset",
            "{",
            "    vector<uint64_t> bits;",
            "    int64_t b, n;",
            "",
            "    Bitset(int64_t _b = 0)",
            "    {",
            "        init(_b);",
            "    }",
            "",
            "    void init(int64_t _b)",
            "    {",
            "        b = _b;",
            "        n = (b + 63) / 64;",
            "        bits.assign(n, 0);",
            "    }",
            "",
            "    void clear()",
            "    {",
            "        b = n = 0;",
            "        bits.clear();",
            "    }",
            "",
            "    void reset()",
            "    {",
            "        bits.assign(n, 0);",
            "    }",
            "",
            "    void _clean()",
            "    {",
            "        // Reset all bits after `b`.",
            "        if (b != 64 * n)",
            "            bits.back() &= (1LLU << (b - 64 * (n - 1))) - 1;",
            "    }",
            "",
            "    bool get(int64_t index) const",
            "    {",
            "        return bits[index / 64] >> (index % 64) & 1;",
            "    }",
            "",
            "    void set(int64_t index, bool value)",
            "    {",
            "        assert(0 <= index && index < b);",
            "        bits[index / 64] &= ~(1LLU << (index % 64));",
            "        bits[index / 64] |= uint64_t(value) << (index % 64);",
            "    }",
            "",
            "    // Simulates `bs |= bs << shift;`",
            "    void left_shift(int64_t shift)",
            "    {",
            "        int64_t div = shift / 64, mod = shift % 64;",
            "",
            "        if (mod == 0)",
            "        {",
            "            for (int64_t i = n - 1; i >= div; i--)",
            "                bits[i] |= bits[i - div];",
            "",
            "            return;",
            "        }",
            "",
            "        for (int64_t i = n - 1; i >= div + 1; i--)",
            "            bits[i] |= bits[i - (div + 1)] >> (64 - mod) | bits[i - div] << mod;",
            "",
            "        if (div < n)",
            "            bits[div] |= bits[0] << mod;",
            "",
            "        _clean();",
            "    }",
            "",
            "    // Simulates `bs |= bs >> shift;`",
            "    void right_shift(int64_t shift)",
            "    {",
            "        int64_t div = shift / 64, mod = shift % 64;",
            "",
            "        if (mod == 0)",
            "        {",
            "            for (int64_t i = div; i < n; i++)",
            "                bits[i - div] |= bits[i];",
            "",
            "            return;",
            "        }",
            "",
            "        for (int64_t i = 0; i < n - (div + 1); i++)",
            "            bits[i] |= bits[i + (div + 1)] << (64 - mod) | bits[i + div] >> mod;",
            "",
            "        if (div < n)",
            "            bits[n - div - 1] |= bits[n - 1] >> mod;",
            "",
            "        _clean();",
            "    }",
            "",
            "    int64_t find_first() const",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "            if (bits[i] != 0)",
            "                return 64 * i + __builtin_ctzll(bits[i]);",
            "",
            "        return -1;",
            "    }",
            "    int64_t find_next(int x) const",
            "    {",
            "        for (int i = x + 1; i < x + 64; i++)",
            "        {",
            "            if (get(i))",
            "                return i;",
            "        }",
            "        for (int i = x / 64 + 1; i < n; i++)",
            "            if (bits[i] != 0)",
            "                return 64 * i + __builtin_ctzll(bits[i]);",
            "",
            "        return 1e9;",
            "    }",
            "",
            "    Bitset &operator&=(const Bitset &other)",
            "    {",
            "        assert(b == other.b);",
            "",
            "        for (int i = 0; i < n; i++)",
            "            bits[i] &= other.bits[i];",
            "",
            "        return *this;",
            "    }",
            "};"
        ],
        "description": "Bitset Memory Efficient"
    },
    "Dynamic Connectivity": {
        "prefix": "connectivity",
        "body": [
            "struct node",
            "{",
            "    int u, v, u_size;",
            "};",
            " ",
            "stack<node> info;",
            "int u[MXN], v[MXN], t[MXN], res[MXN], par[MXN], level[MXN], cmp;",
            "int f(int x)",
            "{",
            "    return x == par[x] ? x : f(par[x]);",
            "}",
            "int unite(int u, int v)",
            "{",
            "    u = f(u);",
            "    v = f(v);",
            " ",
            "    if (u != v)",
            "    {",
            "        if (level[u] < level[v])",
            "            swap(u, v);",
            " ",
            "        node cur;",
            "        cur.u = u;",
            "        cur.v = v;",
            "        cur.u_size = level[u];",
            "        info.push(cur);",
            " ",
            "        par[v] = u;",
            "        if (level[u] == level[v])",
            "            ++level[u];",
            "        return true;",
            "    }",
            "    return false;",
            "}",
            " ",
            "class SegmentTree",
            "{",
            "public:",
            "    vector<vector<int>> segTree;",
            " ",
            "    SegmentTree(int n)",
            "    {",
            "        segTree.resize(4 * n);",
            "    }",
            " ",
            "    void query(int id, int left, int right)",
            "    {",
            "        int track = sz(info);",
            "        for (int ii : segTree[id])",
            "            cmp -= unite(u[ii], v[ii]);",
            " ",
            "        if (left == right)",
            "            res[left] = cmp;",
            " ",
            "        if (left != right)",
            "        {",
            "            int mid = (left + right) / 2;",
            "            query(2 * id, left, mid);",
            "            query(2 * id + 1, 1 + mid, right);",
            "        }",
            " ",
            "        while (sz(info) != track)",
            "        {",
            "            ++cmp;",
            "            node cur = info.top();",
            "            par[cur.u] = cur.u;",
            "            par[cur.v] = cur.v;",
            "            level[cur.u] = cur.u_size;",
            "            info.pop();",
            "        }",
            "    }",
            " ",
            "    void update(int id, int left, int right, int l, int r, int val)",
            "    {",
            "        if (l > r)",
            "            return;",
            "        if (left == l && right == r)",
            "        {",
            "            segTree[id].push_back(val);",
            "            return;",
            "        }",
            "        int mid = (left + right) / 2;",
            "        update(2 * id, left, mid, l, min(mid, r), val);",
            "        update(2 * id + 1, 1 + mid, right, max(1 + mid, l), r, val);",
            "    }",
            "};",
            " ",
            "void sol(int tc)",
            "{",
            "    int n, m;",
            "    cin >> n >> m;",
            "    rep(ii, 0, m, 1)",
            "    {",
            "        string s;",
            "        cin >> s;",
            "        if (s == \"+\" || s == \"-\")",
            "        {",
            "            cin >> u[ii] >> v[ii];",
            "            if (u[ii] > v[ii])",
            "                swap(u[ii], v[ii]);",
            "            t[ii] = s == \"+\" ? 1 : 2;",
            "        }",
            "        else",
            "            t[ii] = 0;",
            "    }",
            "    rep(ii, 0, n, 1) par[ii + 1] = ii + 1;",
            "    SegmentTree seg(m);",
            "    map<pair<int, int>, int> id;",
            "    rep(ii, 0, m, 1)",
            "    {",
            "        if (t[ii] == 0)",
            "            continue;",
            "        if (t[ii] == 1)",
            "        {",
            "            id[{u[ii], v[ii]}] = ii + 1;",
            "            continue;",
            "        }",
            "        seg.update(1, 0, m - 1, id[{u[ii], v[ii]}] - 1, ii, ii);",
            "        id[{u[ii], v[ii]}] = 0;",
            "    }",
            "    for (auto ii : id)",
            "    {",
            "        if (ii.second != 0)",
            "            seg.update(1, 0, m - 1, ii.second - 1, m - 1, ii.second - 1);",
            "    }",
            "    cmp = n;",
            "    if (m)",
            "        seg.query(1, 0, m - 1);",
            "    rep(ii, 0, m, 1) if (t[ii] == 0) cout << res[ii] << \"\\n\";",
            "}",
            " ",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            " ",
            "    files;",
            "    int T = 1;",
            "    // cin >> T;",
            "    for (int ii = 1; ii <= T; ++ii)",
            "        sol(ii);",
            "}"
        ],
        "description": "Dynamic Connectivity"
    }
}